---
layout: post
title: "Memahami Konsep Pointer pada Bahasa Pemrograman Go"
categories: tips
---

Buat programmer yang belum familiar dengan bahasa Go (atau bahasa C sejenisnya), pointer menjadi barang baru yang konsepnya cukup tricky. Oleh karena itu, mari kita eksplorasi pointer di Go!

## Pointer dan Memori

Pada dasarnya setiap kita menjalankan aplikasi Go, nilai-nilai dari variabel yang kita buat disimpan di memori. Ada banyak tempat di memori, sehingga untuk mengetahui letak di mana nilai variabel kita disimpan, program kita mencatat dan mengingat alamatnya di memori.

Mantapnya, pada bahasa Go, alamat tersebut dapat juga kita ketahui dengan memanfaatkan pointer. Singkatnya, pointer adalah tipe data yang menyimpan alamat dari sebuah variabel di memori.

Nah untuk membuktikannya langsung saja kita koding seperti berikut. Supaya praktis, kita bisa pakai [Go Playground](https://go.dev/play) untuk praktik.

## 1. Alamat memori dari suatu variabel

Mari jalankan program berikut (klik Run pada Go Playground)

```go
package main

import "fmt"

func main() {
    var x int
    x = 5
	fmt.Println(x, &x)
}
```

Di sini kita membuat satu variabel x dengan tipe integer. Hasilnya adalah sebagai berikut


```shell
5 0xc000012070
```

Terlihat bahwa di samping kita bisa mengetahui nilai variabel, pada bahasa Go kita juga bisa tahu alamatnya di memori. Untuk membongkar letak alamatnya, kita dapat menambahkan operator **reference** (&) di depan variabel.

```
*Catatan*: bisa jadi alamat memori yang tercetak di komputer dengan yang ada di tutorial ini berbeda. Ini wajar. Kalau kita jalankan ulang programnya, boleh jadi kita akan dapat hasil yang berbeda juga. 
```

## 2. Menampung alamat dengan pointer

Jalankan kode berikut

```go
package main

import "fmt"

func main() {
    var x int
    var y *int
    x = 5
    y = &x
	fmt.Println(x, y)
}
```

Hasilnya sebagai berikut

```
5 0xc000012070
```

Kita akan mendapatkan hasil serupa dengan (1). Ini menandakan bahwa kita bisa membuat variabel untuk menampung alamat memori dari variabel lainnya. Variabel yang seperti inilah yang disebut sebagai **pointer**.

Untuk menginisiasi (membuat baru) variabel pointer, kita menggunakan tanda (*) di depan nama variabelnya.


## 3. Mendapatkan value yang ditunjuk pointer

Tanda (*) juga dapat digunakan untuk mendapatkan value dari variabel yang ditunjuk pointer. Ini disebut operator dereference. Caranya seperti berikut

```go
package main

import "fmt"

func main() {
	var x int
	var y *int
	x = 5
	y = &x
	fmt.Println(y, *y)
}
```

Jika dijalankan maka output dari y adalah alamat memori x sedangkan output *y adalah nilai dari x.

## 4. Pass by value

Function di Go menganut pass-by-value. Artinya, yang dioper oleh pemanggil ke sebuah function adalah nilainya saja, sedangkan alamat memorinya berbeda.

```go
package main

import "fmt"

func passByValue(x int) {
	fmt.Printf("Inside function %d %p \n", x, &x)
}

func main() {
	x := 5
	passByValue(x)
	fmt.Printf("Outside function %d %p \n", x, &x)
}
```

Jika dijalankan outputnya adalah seperti berikut

```shell
Inside function 5 0xc000012078 
Outside function 5 0xc000012070
```

Value (nilai) dari x di dalam dan di luar fungsi tentu sama, tapi disimpan dalam alamat yang berbeda. 

Salah satu efeknya, modifikasi nilai x di dalam fungsi tidak mempengaruhi x di luar fungsi.

```go
package main

import "fmt"

func passByValue(x int) {
	x = 10
	fmt.Printf("Inside function %d %p \n", x, &x)
}

func main() {
	x := 5
	passByValue(x)
	fmt.Printf("Outside function %d %p \n", x, &x)
}
```

Jika dijalankan, nilai x di dalam fungsi adalah 10, sedangkan nilai x di luarnya tetaplah 5.

Di balik layar, yang dilakukan Go adalah membuat variabel lokal baru x (yang hanya berlaku di dalam fungsi) yang nilainya di-copy dari nilai x pemanggilnya, tetapi karena dibuat baru maka alamatnya berbeda.

## 5. Pass pointer ke fungsi

Kalau demikian, adakah cara mengubah nilai di luar fungsi? Dengan Go, kita bisa mengoper nilai pointer (menggunakan operator dereference) sehingga kita dapat memodifikasi nilai di luar fungsi.

```go
package main

import "fmt"

func passByReference(x *int) {
	*x = 10
	fmt.Printf("Inside function %d %p \n", *x, x)
}

func main() {
	x := 5
	passByReference(&x)
	fmt.Printf("Outside function %d %p \n", x, &x)
}
```

Pada fungsi passByReference, kita mengubah nilai underlying dari pointer x, yang tadinya 5 menjadi 10 dengan operator dereference (*). Setelah itu kita print nilai yang telah kita ubah (yaitu *x) dan pointernya (x). 

Ini sedikit berbeda dengan x di luar function yang bukan berupa pointer. Selain itu, untuk mengoper pointer kita menggunakan operator reference (&x) dalam pemanggilan fungsi passByReference.

Jika program dijalankan maka hasilnya sebagai berikut

```shell
Inside function 10 0xc000012070 
Outside function 10 0xc000012070 
```

Sekarang nilai di luar fungsi ikut berubah menjadi 10, karena yang kita modifikasi adalah pointernya.

Perlu diingat bahwa x dalam fungsi tidak sama dengan pointer &x di luar fungsi. Yang dilakukan Go adalah membuat pointer lokal baru x yang nilainya di-copy dari pointer &x (di luar fungsi) yang digunakan untuk memanggil fungsi tersebut.

## 6. Setter dan getter

Salah satu penerapan pointer yang paling umum adalah setter dan getter method pada suatu struct.

```go
package main

import "fmt"

type Person struct {
	name string
}

func NewPerson(name string) Person {
	return Person{name}
}

func (p Person) Name() string {
	return p.name
}

func (p *Person) SetName(name string) {
	p.name = name
}

func main() {
	p := NewPerson("Andy")
	fmt.Println(p.Name())
	p.SetName("Handy")
	fmt.Println(p.Name())
}
```

Jika dijalankan maka nama berubah dari Andy menjadi Handy. 

Ada hal yang unik di sini. Untuk mengubah p.name tidak diperlukan operator dereference `(*p).name = name` karena compiler Go dapat mendeteksi hal ini.

```
*Catatan*: dalam Go, best practicenya adalah method-method yang memiliki side effect atau mengubah nilai di luar fungsi harus menggunakan pointer receiver atau parameter berupa pointer, sedangkan method-method yang hanya membaca nilai menggunakan value recevier atau parameter biasa. Ada juga yang menyarankan untuk selalu memakai pointer untuk menunjuk struct yang menyimpan data berukuran besar.
```

## 7. List/Map of Struct

Untuk membuat list yang dapat memodifikasi struct secara global, kita dapat memanfaatkan pointer. 

Sebagai contoh, mari lihat dan jalankan kode berikut

```go
package main

import "fmt"

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	p0 := Person{"Andy", "Timmons"}
	p1 := Person{"Ardy", "Putra"}

	persons := []Person{p0, p1}

	persons[0].LastName = "Caroll"

	fmt.Println(p0.LastName)
}
```

Pada saat dijalankan, LastName tidak berubah dari Timmons menjadi Caroll. Ini terjadi karena persons[0] berbeda dengan p0. 

Pada saat membuat list, nilai dari p0 di-copy, dan copy-nya dijadikan persons[0]. Karena berupa copy, maka alamat keduanya di memori berbeda. Karena alamatnya berbeda, perubahan pada salah satu variabel tidak mempengaruhi yang lainnya.

Ini dapat diatasi dengan mudah dengan pointer.

```go
package main

import "fmt"

type Person struct {
	FirstName string
	LastName  string
}

func main() {
	p0 := Person{"Andy", "Timmons"}
	p1 := Person{"Ardy", "Putra"}

	persons := []*Person{&p0, &p1}

	persons[0].LastName = "Caroll"

	fmt.Println(p0.LastName)
}
```

Setelah dijalankan ulang, outputnya menjadi Caroll.

Ini karena p0 dan persons[0] berupa pointer (yang menunjuk ke alamat yang sama), sekarang perubahan value yang ditunjuk persons[0] ikut mengubah value yang ditunjuk p0.

Hal yang serupa dapat juga diterapkan untuk value dari map.

## 8. Pointer nil

Sebuah pointer bisa jadi dibuat tidak menunjuk variabel apapun. Dalam hal ini, nilai dari pointer bukanlah alamat memori, melainkan nilai kosong yang disebut dengan **nil**.

```go
package main

import "fmt"

func main() {
	var p *int
	p = nil
	fmt.Println(p)
}
```

Output dari kode di atas adalah "nil". Lalu, apa yang terjadi jika kita melakukan operasi dereference (*)?

```go
package main

import "fmt"

func main() {
	var p *int
	p = nil
	fmt.Println(*p)
}
```

Ternyata, program akan mengalami runtime error (panic). Ini terjadi karena memang tidak ada yang ditunjuk oleh sebuah pointer nil, sehingga valuenya jelas nihil.

```shell
panic: runtime error: invalid memory address or nil pointer dereference
[signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x48eb36]

goroutine 1 [running]:
main.main()
	/tmp/sandbox1296800962/prog.go:8 +0x16

Program exited.
```

## 9. Error object

Penerapan umum pointer lainnya adalah pada error object. Pada bahasa Go, tidak terdapat stack trace atau fungsionalitas try-catch untuk menangkap error. Dengan demikian, sejatinya objek error di Go adalah struct biasa.

```go
package main

import (
	"errors"
	"fmt"
)

type CharError struct {
	Message string
}

func (e *CharError) Error() string {
	return e.Message
}

func firstChar(s string) (string, error) {
	if len(s) == 0 {
		return "", &CharError{"Length of string s is zero"}
	}
	return s[:1], nil

}

func main() {
	first, err := firstChar("")
	if err != nil {
		var charError *CharError

		if errors.As(err, &charError) {
			fmt.Println("Empty input certainly don't have first character")
			return
		}

		fmt.Println("Unexpected error: ", err.Error())
		return
	}
	fmt.Println("The first character of the input is", first)
}
```

Di sini terlihat bahwa error dioper dari fungsi firstChar sebagai pointer. Kemudian, `if err != nil` digunakan untuk menangkap error. Apabila error terjadi maka akan masuk ke blok if, dan sebaliknya.

Jika program di atas dijalankan, maka outputnya adalah `Empty input certainly don't have first character`.

## 10. Pointer dan Interface

Pointer (misalnya pointer ke suatu struct) juga bisa digunakan sebagai implementasi dari interface. Sebagai contoh, kita dapat membuat kode sebagai berikut.

```go
package main

import "fmt"

type Vehicle interface {
	Start()
	Stop()
}

type Car struct {
	Power string
}

func (c *Car) Start() {
	c.Power = "On"
}

func (c *Car) Stop() {
	c.Power = "Off"
}

func main() {
	var jaguar Vehicle = &Car{}
	jaguar.Start()
	fmt.Println(jaguar.(*Car).Power)
}
```

Ketika dijalankan, kita membuat sebuah variabel jaguar yang merupakan pointer ke suatu Car. Di sini, pointer &Car-lah yang dianggap mengimplementasi interface Vehicle (bukan Car itu sendiri).

Salah satu kesalahan umum adalah menggunakan pointer to interface untuk mewakili fungsionalitas suatu pointer. Sebagai contoh, kode berikut menghasilkan error.

```go
package main

type Vehicle interface {
	Start()
	Stop()
}

type Car struct {
	Power string
}

func (c *Car) Start() {
	c.Power = "On"
}

func (c *Car) Stop() {
	c.Power = "Off"
}

func main() {
	var jaguar *Vehicle = &Car{}
}
```

Pesan errornya berbunyi seperti demikian

```shell
./prog.go:21:24: cannot use &Car{} (value of type *Car) as *Vehicle value in variable declaration: *Car does not implement *Vehicle (type *Vehicle is pointer to interface, not interface)
```

Perlu dicatat bahwa pointer ke interface **bukanlah** interface. Ia adalah concrete type yang menyimpan alamat dari suatu interface, dan ini tidak umum digunakan.

Untuk memperbaiki error di atas, cukup deklarasikan `jaguar` sebagai `Vehicle`, bukan `*Vehicle`.



## Referensi

[Pointers Explained](https://yourbasic.org/golang/pointers-explained/)

[Go Pointer](https://wahyu-ehs.medium.com/go-pointer-47f1ed099682)

[Menggunakan Pointer di Golang dengan Mudah](https://husniadil.com/menggunakan-pointer-di-golang-dengan-mudah/)